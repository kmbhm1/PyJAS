{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"api/api-reference/","title":"API Reference","text":""},{"location":"api/api-reference/#v11","title":"v1.1","text":""},{"location":"api/api-reference/#content-type","title":"Content Type","text":""},{"location":"api/api-reference/#pyjas.v1_1.content_negotiation.AcceptHeaderError","title":"<code>AcceptHeaderError</code>","text":"<p>               Bases: <code>Exception</code></p> <p>Custom exception for accept header errors.</p> Source code in <code>pyjas/v1_1/content_negotiation.py</code> <pre><code>class AcceptHeaderError(Exception):\n    \"\"\"Custom exception for accept header errors.\"\"\"\n\n    pass\n</code></pre>"},{"location":"api/api-reference/#pyjas.v1_1.content_negotiation.ContentNegotiation","title":"<code>ContentNegotiation</code>","text":"<p>Class to handle content negotiation according to the JSON:API specification.</p> Source code in <code>pyjas/v1_1/content_negotiation.py</code> <pre><code>class ContentNegotiation:\n    \"\"\"Class to handle content negotiation according to the JSON:API specification.\"\"\"\n\n    def __init__(self, supported_extensions: list[str] | None = None):\n        \"\"\"Initialize with the list of supported extension URIs.\"\"\"\n        self.supported_extensions = set(supported_extensions or [])\n\n    def validate_content_type_header(self, content_type_str: str) -&gt; None:\n        \"\"\"Validate the Content-Type header of a request.\n\n        Raises:\n            ContentTypeError: If the Content-Type header is invalid.\n        \"\"\"\n        try:\n            content_type = ContentType.parse(content_type_str)\n        except ContentTypeError as e:\n            raise ContentTypeError(f'Invalid Content-Type header: {e}')\n\n        # Check for unsupported parameters\n        unsupported_params = set(content_type.params.keys()) - ContentType.ALLOWED_PARAMS\n        if unsupported_params:\n            raise ContentTypeError(\n                f\"Invalid parameter(s) in Content-Type header: {', '.join(unsupported_params)}. \"\n                f\"Only 'ext' and 'profile' are allowed.\"\n            )\n\n        # Check for unsupported extensions\n        if 'ext' in content_type.params:\n            unsupported_exts = set(content_type.extensions) - self.supported_extensions\n            if unsupported_exts:\n                raise ContentTypeError(\n                    f\"Unsupported extension(s) in Content-Type header: {', '.join(unsupported_exts)}\"\n                )\n\n    def validate_accept_header(self, accept_header: str) -&gt; None:\n        \"\"\"Validate the Accept header of a request.\n\n        Raises:\n            AcceptHeaderError: If the Accept header is invalid or not acceptable.\n        \"\"\"\n        # Parse the Accept header\n        media_ranges = self._parse_accept_header(accept_header)\n        jsonapi_media_types = [\n            media_range for media_range in media_ranges if media_range['media_type'] == ContentType.MEDIA_TYPE\n        ]\n\n        # Remove media types with invalid parameters\n        valid_media_types = []\n        for media_range in jsonapi_media_types:\n            params = media_range['params']\n            invalid_params = set(params.keys()) - ContentType.ALLOWED_PARAMS\n            if invalid_params:\n                # Ignore this media type as per spec\n                continue\n            else:\n                valid_media_types.append(media_range)\n\n        if not valid_media_types:\n            raise AcceptHeaderError('No acceptable media types found in Accept header.')\n\n        # Check for unsupported extensions\n        all_exts_unsupported = True\n        for media_range in valid_media_types:\n            exts = media_range['params'].get('ext', [])\n            if not exts or set(exts).issubset(self.supported_extensions):\n                all_exts_unsupported = False\n                break\n\n        if all_exts_unsupported:\n            raise AcceptHeaderError('No acceptable media types found due to unsupported extensions.')\n\n    def generate_vary_header(self) -&gt; str:\n        \"\"\"Generate the Vary header.\n\n        Returns:\n            str: The Vary header value.\n        \"\"\"\n        return 'Accept'\n\n    def _parse_accept_header(self, accept_header: str) -&gt; list[dict[str, Any]]:\n        \"\"\"Parse the Accept header into a list of media ranges.\n\n        Returns:\n            List[Dict[str, Any]]: List of media ranges with media_type, q, and params.\n        \"\"\"\n        media_ranges: list[dict[str, Any]] = []\n        for media_range_str in accept_header.split(','):\n            media_range_str = media_range_str.strip()\n            if not media_range_str:\n                continue\n            # Split media type and parameters\n            parts = [part.strip() for part in media_range_str.split(';') if part.strip()]\n            media_type = parts[0]\n            params = {}\n            q = 1.0\n            for param in parts[1:]:\n                if '=' not in param:\n                    continue\n                key, value = param.split('=', 1)\n                key = key.strip()\n                value = value.strip().strip('\"')  # Remove quotes\n                if key == 'q':\n                    try:\n                        q = float(value)\n                    except ValueError:\n                        pass  # Ignore invalid q values\n                else:\n                    # Handle ext and profile parameters\n                    if key in ContentType.ALLOWED_PARAMS:\n                        uris = value.split()\n                        params[key] = uris\n            media_ranges.append({'media_type': media_type, 'q': q, 'params': params})\n\n        # Sort by q value descending\n        media_ranges.sort(key=lambda x: x['q'], reverse=True)  # mypy: ignore\n        return media_ranges  # mypy: ignore\n</code></pre>"},{"location":"api/api-reference/#pyjas.v1_1.content_negotiation.ContentNegotiation.__init__","title":"<code>__init__(supported_extensions=None)</code>","text":"<p>Initialize with the list of supported extension URIs.</p> Source code in <code>pyjas/v1_1/content_negotiation.py</code> <pre><code>def __init__(self, supported_extensions: list[str] | None = None):\n    \"\"\"Initialize with the list of supported extension URIs.\"\"\"\n    self.supported_extensions = set(supported_extensions or [])\n</code></pre>"},{"location":"api/api-reference/#pyjas.v1_1.content_negotiation.ContentNegotiation.generate_vary_header","title":"<code>generate_vary_header()</code>","text":"<p>Generate the Vary header.</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The Vary header value.</p> Source code in <code>pyjas/v1_1/content_negotiation.py</code> <pre><code>def generate_vary_header(self) -&gt; str:\n    \"\"\"Generate the Vary header.\n\n    Returns:\n        str: The Vary header value.\n    \"\"\"\n    return 'Accept'\n</code></pre>"},{"location":"api/api-reference/#pyjas.v1_1.content_negotiation.ContentNegotiation.validate_accept_header","title":"<code>validate_accept_header(accept_header)</code>","text":"<p>Validate the Accept header of a request.</p> <p>Raises:</p> Type Description <code>AcceptHeaderError</code> <p>If the Accept header is invalid or not acceptable.</p> Source code in <code>pyjas/v1_1/content_negotiation.py</code> <pre><code>def validate_accept_header(self, accept_header: str) -&gt; None:\n    \"\"\"Validate the Accept header of a request.\n\n    Raises:\n        AcceptHeaderError: If the Accept header is invalid or not acceptable.\n    \"\"\"\n    # Parse the Accept header\n    media_ranges = self._parse_accept_header(accept_header)\n    jsonapi_media_types = [\n        media_range for media_range in media_ranges if media_range['media_type'] == ContentType.MEDIA_TYPE\n    ]\n\n    # Remove media types with invalid parameters\n    valid_media_types = []\n    for media_range in jsonapi_media_types:\n        params = media_range['params']\n        invalid_params = set(params.keys()) - ContentType.ALLOWED_PARAMS\n        if invalid_params:\n            # Ignore this media type as per spec\n            continue\n        else:\n            valid_media_types.append(media_range)\n\n    if not valid_media_types:\n        raise AcceptHeaderError('No acceptable media types found in Accept header.')\n\n    # Check for unsupported extensions\n    all_exts_unsupported = True\n    for media_range in valid_media_types:\n        exts = media_range['params'].get('ext', [])\n        if not exts or set(exts).issubset(self.supported_extensions):\n            all_exts_unsupported = False\n            break\n\n    if all_exts_unsupported:\n        raise AcceptHeaderError('No acceptable media types found due to unsupported extensions.')\n</code></pre>"},{"location":"api/api-reference/#pyjas.v1_1.content_negotiation.ContentNegotiation.validate_content_type_header","title":"<code>validate_content_type_header(content_type_str)</code>","text":"<p>Validate the Content-Type header of a request.</p> <p>Raises:</p> Type Description <code>ContentTypeError</code> <p>If the Content-Type header is invalid.</p> Source code in <code>pyjas/v1_1/content_negotiation.py</code> <pre><code>def validate_content_type_header(self, content_type_str: str) -&gt; None:\n    \"\"\"Validate the Content-Type header of a request.\n\n    Raises:\n        ContentTypeError: If the Content-Type header is invalid.\n    \"\"\"\n    try:\n        content_type = ContentType.parse(content_type_str)\n    except ContentTypeError as e:\n        raise ContentTypeError(f'Invalid Content-Type header: {e}')\n\n    # Check for unsupported parameters\n    unsupported_params = set(content_type.params.keys()) - ContentType.ALLOWED_PARAMS\n    if unsupported_params:\n        raise ContentTypeError(\n            f\"Invalid parameter(s) in Content-Type header: {', '.join(unsupported_params)}. \"\n            f\"Only 'ext' and 'profile' are allowed.\"\n        )\n\n    # Check for unsupported extensions\n    if 'ext' in content_type.params:\n        unsupported_exts = set(content_type.extensions) - self.supported_extensions\n        if unsupported_exts:\n            raise ContentTypeError(\n                f\"Unsupported extension(s) in Content-Type header: {', '.join(unsupported_exts)}\"\n            )\n</code></pre>"},{"location":"api/api-reference/#pyjas.v1_1.content_negotiation.ContentType","title":"<code>ContentType</code>","text":"Source code in <code>pyjas/v1_1/content_negotiation.py</code> <pre><code>class ContentType:\n    MEDIA_TYPE = 'application/vnd.api+json'\n    ALLOWED_PARAMS = {'ext', 'profile'}\n\n    def __init__(self, media_type: str, params: dict[str, list[str]]):\n        self.media_type = media_type\n        self.params = params\n        self.validate()\n\n    @classmethod\n    def parse(cls, content_type_str: str) -&gt; 'ContentType':\n        \"\"\"Parse a content type string and return a ContentType instance.\"\"\"\n        # Split media type and parameters\n        parts = [part.strip() for part in content_type_str.split(';') if part.strip()]\n        if not parts:\n            raise ContentTypeError('Content-Type header is empty.')\n\n        media_type = parts[0]\n        params = {}\n        for param in parts[1:]:\n            if '=' not in param:\n                raise ContentTypeError(f\"Invalid parameter format: '{param}'\")\n            key, value = param.split('=', 1)\n            key = key.strip()\n            value = value.strip().strip('\"')  # Remove surrounding quotes\n\n            if key not in cls.ALLOWED_PARAMS:\n                raise ContentTypeError(f\"Invalid parameter '{key}'. Only 'ext' and 'profile' are allowed.\")\n\n            # Split value by spaces to get list of URIs\n            uris = value.split()\n            # Validate URIs\n            for uri in uris:\n                if not cls._is_valid_uri(uri):\n                    raise ContentTypeError(f\"Invalid URI in '{key}': '{uri}'\")\n            params[key] = uris\n\n        return cls(media_type=media_type, params=params)\n\n    def validate(self) -&gt; None:\n        \"\"\"Validate the media type and parameters according to the JSON:API spec.\"\"\"\n        # Validate media type\n        if self.media_type != self.MEDIA_TYPE:\n            raise ContentTypeError(f\"Invalid media type '{self.media_type}'. Expected '{self.MEDIA_TYPE}'.\")\n\n        # Validate parameters\n        for key in self.params.keys():\n            if key not in self.ALLOWED_PARAMS:\n                raise ContentTypeError(f\"Invalid parameter '{key}'. Only 'ext' and 'profile' are allowed.\")\n\n        # Ensure parameter values are lists of URIs\n        for key, uris in self.params.items():\n            if not isinstance(uris, list):\n                raise ContentTypeError(f\"The value of '{key}' must be a list of URIs.\")\n            for uri in uris:\n                if not self._is_valid_uri(uri):\n                    raise ContentTypeError(f\"Invalid URI in '{key}': '{uri}'\")\n\n    @staticmethod\n    def _is_valid_uri(uri: str) -&gt; bool:\n        \"\"\"Check if a string is a valid URI.\"\"\"\n        result = urlparse(uri)\n        return all([result.scheme, result.netloc])\n\n    @property\n    def extensions(self) -&gt; list[str]:\n        \"\"\"Return the list of extension URIs.\"\"\"\n        return self.params.get('ext', [])\n\n    @property\n    def profiles(self) -&gt; list[str]:\n        \"\"\"Return the list of profile URIs.\"\"\"\n        return self.params.get('profile', [])\n\n    def to_string(self) -&gt; str:\n        \"\"\"Serialize the ContentType back to a string.\"\"\"\n        parts = [self.media_type]\n        for key in sorted(self.params.keys()):\n            # Join URIs with spaces\n            value = ' '.join(self.params[key])\n            # Surround value with quotes\n            parts.append(f'{key}=\"{value}\"')\n        return '; '.join(parts)\n\n    @classmethod\n    def create(\n        cls,\n        extensions: list[str] | None = None,\n        profiles: list[str] | None = None,\n    ) -&gt; 'ContentType':\n        \"\"\"Create a ContentType instance with the given extensions and profiles.\"\"\"\n        params = {}\n        if extensions:\n            for uri in extensions:\n                if not cls._is_valid_uri(uri):\n                    raise ContentTypeError(f\"Invalid URI in 'extensions': '{uri}'\")\n            params['ext'] = extensions\n        if profiles:\n            for uri in profiles:\n                if not cls._is_valid_uri(uri):\n                    raise ContentTypeError(f\"Invalid URI in 'profiles': '{uri}'\")\n            params['profile'] = profiles\n        return cls(media_type=cls.MEDIA_TYPE, params=params)\n</code></pre>"},{"location":"api/api-reference/#pyjas.v1_1.content_negotiation.ContentType.extensions","title":"<code>extensions: list[str]</code>  <code>property</code>","text":"<p>Return the list of extension URIs.</p>"},{"location":"api/api-reference/#pyjas.v1_1.content_negotiation.ContentType.profiles","title":"<code>profiles: list[str]</code>  <code>property</code>","text":"<p>Return the list of profile URIs.</p>"},{"location":"api/api-reference/#pyjas.v1_1.content_negotiation.ContentType.create","title":"<code>create(extensions=None, profiles=None)</code>  <code>classmethod</code>","text":"<p>Create a ContentType instance with the given extensions and profiles.</p> Source code in <code>pyjas/v1_1/content_negotiation.py</code> <pre><code>@classmethod\ndef create(\n    cls,\n    extensions: list[str] | None = None,\n    profiles: list[str] | None = None,\n) -&gt; 'ContentType':\n    \"\"\"Create a ContentType instance with the given extensions and profiles.\"\"\"\n    params = {}\n    if extensions:\n        for uri in extensions:\n            if not cls._is_valid_uri(uri):\n                raise ContentTypeError(f\"Invalid URI in 'extensions': '{uri}'\")\n        params['ext'] = extensions\n    if profiles:\n        for uri in profiles:\n            if not cls._is_valid_uri(uri):\n                raise ContentTypeError(f\"Invalid URI in 'profiles': '{uri}'\")\n        params['profile'] = profiles\n    return cls(media_type=cls.MEDIA_TYPE, params=params)\n</code></pre>"},{"location":"api/api-reference/#pyjas.v1_1.content_negotiation.ContentType.parse","title":"<code>parse(content_type_str)</code>  <code>classmethod</code>","text":"<p>Parse a content type string and return a ContentType instance.</p> Source code in <code>pyjas/v1_1/content_negotiation.py</code> <pre><code>@classmethod\ndef parse(cls, content_type_str: str) -&gt; 'ContentType':\n    \"\"\"Parse a content type string and return a ContentType instance.\"\"\"\n    # Split media type and parameters\n    parts = [part.strip() for part in content_type_str.split(';') if part.strip()]\n    if not parts:\n        raise ContentTypeError('Content-Type header is empty.')\n\n    media_type = parts[0]\n    params = {}\n    for param in parts[1:]:\n        if '=' not in param:\n            raise ContentTypeError(f\"Invalid parameter format: '{param}'\")\n        key, value = param.split('=', 1)\n        key = key.strip()\n        value = value.strip().strip('\"')  # Remove surrounding quotes\n\n        if key not in cls.ALLOWED_PARAMS:\n            raise ContentTypeError(f\"Invalid parameter '{key}'. Only 'ext' and 'profile' are allowed.\")\n\n        # Split value by spaces to get list of URIs\n        uris = value.split()\n        # Validate URIs\n        for uri in uris:\n            if not cls._is_valid_uri(uri):\n                raise ContentTypeError(f\"Invalid URI in '{key}': '{uri}'\")\n        params[key] = uris\n\n    return cls(media_type=media_type, params=params)\n</code></pre>"},{"location":"api/api-reference/#pyjas.v1_1.content_negotiation.ContentType.to_string","title":"<code>to_string()</code>","text":"<p>Serialize the ContentType back to a string.</p> Source code in <code>pyjas/v1_1/content_negotiation.py</code> <pre><code>def to_string(self) -&gt; str:\n    \"\"\"Serialize the ContentType back to a string.\"\"\"\n    parts = [self.media_type]\n    for key in sorted(self.params.keys()):\n        # Join URIs with spaces\n        value = ' '.join(self.params[key])\n        # Surround value with quotes\n        parts.append(f'{key}=\"{value}\"')\n    return '; '.join(parts)\n</code></pre>"},{"location":"api/api-reference/#pyjas.v1_1.content_negotiation.ContentType.validate","title":"<code>validate()</code>","text":"<p>Validate the media type and parameters according to the JSON:API spec.</p> Source code in <code>pyjas/v1_1/content_negotiation.py</code> <pre><code>def validate(self) -&gt; None:\n    \"\"\"Validate the media type and parameters according to the JSON:API spec.\"\"\"\n    # Validate media type\n    if self.media_type != self.MEDIA_TYPE:\n        raise ContentTypeError(f\"Invalid media type '{self.media_type}'. Expected '{self.MEDIA_TYPE}'.\")\n\n    # Validate parameters\n    for key in self.params.keys():\n        if key not in self.ALLOWED_PARAMS:\n            raise ContentTypeError(f\"Invalid parameter '{key}'. Only 'ext' and 'profile' are allowed.\")\n\n    # Ensure parameter values are lists of URIs\n    for key, uris in self.params.items():\n        if not isinstance(uris, list):\n            raise ContentTypeError(f\"The value of '{key}' must be a list of URIs.\")\n        for uri in uris:\n            if not self._is_valid_uri(uri):\n                raise ContentTypeError(f\"Invalid URI in '{key}': '{uri}'\")\n</code></pre>"},{"location":"api/api-reference/#pyjas.v1_1.content_negotiation.ContentTypeError","title":"<code>ContentTypeError</code>","text":"<p>               Bases: <code>Exception</code></p> <p>Custom exception for content type errors.</p> Source code in <code>pyjas/v1_1/content_negotiation.py</code> <pre><code>class ContentTypeError(Exception):\n    \"\"\"Custom exception for content type errors.\"\"\"\n\n    pass\n</code></pre>"},{"location":"api/api-reference/#json-api-reference","title":"JSON API Reference","text":""},{"location":"api/api-reference/#pyjas.v1_1.jsonapi_builder.LinkValue","title":"<code>LinkValue = Union[str, LinkObject, None]</code>  <code>module-attribute</code>","text":"<p>LinkValue: a union type for link values in JSON:API documents.</p> <p>Refer to https://jsonapi.org/format/#document-links for more information.</p> <p>LinkValue can be one of the following types: - str: a string whose value is a URI-reference [RFC3986 Section 4.1]     pointing to the link's target, - LinkObject: a LinkObject instance. - None: a null value if the link does not exist.</p>"},{"location":"api/api-reference/#pyjas.v1_1.jsonapi_builder.Document","title":"<code>Document</code>","text":"<p>               Bases: <code>BaseModel</code></p> Source code in <code>pyjas/v1_1/jsonapi_builder.py</code> <pre><code>class Document(BaseModel):\n    model_config = ConfigDict(extra='allow')\n\n    data: PrimaryData = None\n    errors: list[Any] | None = None  # Error objects can be further defined\n    meta: dict[str, Any] | None = None\n    jsonapi: JSONAPIObject | None = None\n    links: dict[str, LinkValue] | None = None\n    included: list[ResourceObject] | None = None\n\n    @model_validator(mode='after')\n    def validate_document(self) -&gt; Document:\n        \"\"\"Validate the Document according to the JSON:API spec.\"\"\"\n\n        # 1. The members 'data' and 'errors' MUST NOT coexist in the same document.\n        if self.data is not None and self.errors is not None:\n            raise ValueError(\"The members 'data' and 'errors' MUST NOT coexist in the same document.\")\n\n        # 2. A document MUST contain at least one of the following top-level members: data, errors, meta\n        if self.data is None and self.errors is None and self.meta is None and self.jsonapi is None:\n            raise ValueError(\"A document MUST contain at least one of 'data', 'errors', 'meta', or 'jsonapi'.\")\n\n        # 3. If a document does not contain a top-level 'data' key, the 'included' member MUST NOT be present either.\n        if self.data is None and self.included is not None:\n            raise ValueError(\n                \"If a document does not contain a top-level 'data' key, the 'included' member MUST NOT be present.\"\n            )\n\n        # 4. Validate extra members in the document\n        extra_members = self.model_fields_set - set(self.model_fields.keys())\n        if extra_members:\n            for member_name in extra_members:\n                validate_member_name(member_name)\n\n        # 5. Validate 'data' types according to the spec\n        if self.data is not None:\n            valid_types = (ResourceObject, ResourceIdentifierObject)\n            if isinstance(self.data, list):\n                if not all(isinstance(item, valid_types) for item in self.data):\n                    raise TypeError(\n                        \"All items in 'data' must be 'ResourceObject' or 'ResourceIdentifierObject' instances.\"\n                    )\n            elif not isinstance(self.data, valid_types):\n                raise TypeError(\"'data' must be a 'ResourceObject', 'ResourceIdentifierObject', or a list of them.\")\n\n        # 6. Validate 'included' types\n        if self.included is not None:\n            if not isinstance(self.included, list):\n                raise TypeError(\"'included' must be a list of 'ResourceObject' instances.\")\n            if not all(isinstance(item, ResourceObject) for item in self.included):\n                raise TypeError(\"All items in 'included' must be 'ResourceObject' instances.\")\n\n            # 7. Ensure uniqueness in 'included' (no duplicates by type and id/lid)\n            seen_resources: set[tuple[str, str | None]] = set()\n            for resource in self.included:\n                identifier = (resource.type_, resource.id_) if resource.id_ else (resource.type_, resource.lid)\n                if identifier in seen_resources:\n                    raise ValueError(\n                        f\"Duplicate resource in 'included': type='{resource.type_}', id='{resource.id_}' or lid='{resource.lid}'.\"  # noqa: E501\n                    )\n                seen_resources.add(identifier)\n\n            # 8. Ensure all included resources are linked from primary data\n            # Build a set of all reachable resource identifiers from 'data'\n            reachable_resources: set[tuple[str, str | None]] = set()\n            self._traverse_relationships(self.data, reachable_resources)\n\n            # Collect all included resource identifiers\n            included_resources: set[tuple[str, str | None]] = set()\n            for resource in self.included:\n                identifier = (resource.type_, resource.id_) if resource.id_ else (resource.type_, resource.lid)\n                included_resources.add(identifier)\n\n            # Check that all included resources are reachable\n            unreachable = included_resources - reachable_resources\n            if unreachable:\n                raise ValueError(f'Included resources are not reachable from primary data: {unreachable}')\n\n        # 9. Validate links if present\n        if self.links:\n            allowed_links = {'self', 'related', 'describedby'}\n            for link_key, link_value in self.links.items():\n                if link_key not in allowed_links:\n                    raise ValueError(f\"Invalid link key '{link_key}' in Document. Allowed keys: {allowed_links}.\")\n                if link_value is not None and not isinstance(link_value, str | LinkObject):\n                    raise ValueError(f\"Link '{link_key}' must be a string URI, LinkObject, or null.\")\n                if isinstance(link_value, str) and not is_valid_uri(link_value):\n                    raise ValueError(f\"Link '{link_key}' must be a valid URI-reference.\")\n                if isinstance(link_value, LinkObject):\n                    link_value = LinkObject(**link_value.model_dump())  # Ensure LinkObject validation\n\n        return self\n\n    def _traverse_relationships(\n        self,\n        data: PrimaryData,\n        reachable: set[tuple[str, str | None]],\n        visited: set[tuple[str, str | None]] | None = None,\n    ) -&gt; None:\n        \"\"\"Recursively traverse relationships to find all reachable resources.\"\"\"\n        if visited is None:\n            visited = set()\n\n        if data is None:\n            return\n\n        resources: list[Any] = []\n        if isinstance(data, list):\n            resources = data\n        else:\n            resources = [data]\n\n        for resource in resources:\n            identifier = (resource.type_, resource.id_) if resource.id_ else (resource.type_, resource.lid)\n            if identifier in visited:\n                continue\n            visited.add(identifier)\n            reachable.add(identifier)\n\n            if isinstance(resource, ResourceObject) and resource.relationships:\n                for rel in resource.relationships.values():\n                    if rel.data:\n                        if isinstance(rel.data, list):\n                            self._traverse_relationships(rel.data, reachable, visited)\n                        else:\n                            self._traverse_relationships(rel.data, reachable, visited)\n</code></pre>"},{"location":"api/api-reference/#pyjas.v1_1.jsonapi_builder.Document.validate_document","title":"<code>validate_document()</code>","text":"<p>Validate the Document according to the JSON:API spec.</p> Source code in <code>pyjas/v1_1/jsonapi_builder.py</code> <pre><code>@model_validator(mode='after')\ndef validate_document(self) -&gt; Document:\n    \"\"\"Validate the Document according to the JSON:API spec.\"\"\"\n\n    # 1. The members 'data' and 'errors' MUST NOT coexist in the same document.\n    if self.data is not None and self.errors is not None:\n        raise ValueError(\"The members 'data' and 'errors' MUST NOT coexist in the same document.\")\n\n    # 2. A document MUST contain at least one of the following top-level members: data, errors, meta\n    if self.data is None and self.errors is None and self.meta is None and self.jsonapi is None:\n        raise ValueError(\"A document MUST contain at least one of 'data', 'errors', 'meta', or 'jsonapi'.\")\n\n    # 3. If a document does not contain a top-level 'data' key, the 'included' member MUST NOT be present either.\n    if self.data is None and self.included is not None:\n        raise ValueError(\n            \"If a document does not contain a top-level 'data' key, the 'included' member MUST NOT be present.\"\n        )\n\n    # 4. Validate extra members in the document\n    extra_members = self.model_fields_set - set(self.model_fields.keys())\n    if extra_members:\n        for member_name in extra_members:\n            validate_member_name(member_name)\n\n    # 5. Validate 'data' types according to the spec\n    if self.data is not None:\n        valid_types = (ResourceObject, ResourceIdentifierObject)\n        if isinstance(self.data, list):\n            if not all(isinstance(item, valid_types) for item in self.data):\n                raise TypeError(\n                    \"All items in 'data' must be 'ResourceObject' or 'ResourceIdentifierObject' instances.\"\n                )\n        elif not isinstance(self.data, valid_types):\n            raise TypeError(\"'data' must be a 'ResourceObject', 'ResourceIdentifierObject', or a list of them.\")\n\n    # 6. Validate 'included' types\n    if self.included is not None:\n        if not isinstance(self.included, list):\n            raise TypeError(\"'included' must be a list of 'ResourceObject' instances.\")\n        if not all(isinstance(item, ResourceObject) for item in self.included):\n            raise TypeError(\"All items in 'included' must be 'ResourceObject' instances.\")\n\n        # 7. Ensure uniqueness in 'included' (no duplicates by type and id/lid)\n        seen_resources: set[tuple[str, str | None]] = set()\n        for resource in self.included:\n            identifier = (resource.type_, resource.id_) if resource.id_ else (resource.type_, resource.lid)\n            if identifier in seen_resources:\n                raise ValueError(\n                    f\"Duplicate resource in 'included': type='{resource.type_}', id='{resource.id_}' or lid='{resource.lid}'.\"  # noqa: E501\n                )\n            seen_resources.add(identifier)\n\n        # 8. Ensure all included resources are linked from primary data\n        # Build a set of all reachable resource identifiers from 'data'\n        reachable_resources: set[tuple[str, str | None]] = set()\n        self._traverse_relationships(self.data, reachable_resources)\n\n        # Collect all included resource identifiers\n        included_resources: set[tuple[str, str | None]] = set()\n        for resource in self.included:\n            identifier = (resource.type_, resource.id_) if resource.id_ else (resource.type_, resource.lid)\n            included_resources.add(identifier)\n\n        # Check that all included resources are reachable\n        unreachable = included_resources - reachable_resources\n        if unreachable:\n            raise ValueError(f'Included resources are not reachable from primary data: {unreachable}')\n\n    # 9. Validate links if present\n    if self.links:\n        allowed_links = {'self', 'related', 'describedby'}\n        for link_key, link_value in self.links.items():\n            if link_key not in allowed_links:\n                raise ValueError(f\"Invalid link key '{link_key}' in Document. Allowed keys: {allowed_links}.\")\n            if link_value is not None and not isinstance(link_value, str | LinkObject):\n                raise ValueError(f\"Link '{link_key}' must be a string URI, LinkObject, or null.\")\n            if isinstance(link_value, str) and not is_valid_uri(link_value):\n                raise ValueError(f\"Link '{link_key}' must be a valid URI-reference.\")\n            if isinstance(link_value, LinkObject):\n                link_value = LinkObject(**link_value.model_dump())  # Ensure LinkObject validation\n\n    return self\n</code></pre>"},{"location":"api/api-reference/#pyjas.v1_1.jsonapi_builder.JSONAPIObject","title":"<code>JSONAPIObject</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>JSONAPIObject enforces the JSON:API version in a JSON:API document.</p> <p>Refer to https://jsonapi.org/format/#document-jsonapi-object for more information.</p> Required fields <p>version (str): The JSON:API version. Default is '1.1'.</p> Optional fields <p>meta (dict): a meta object containing non-standard meta-information about the JSON:API document.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>ensure 'version' is one of the allowed JSON:API versions.</p> Source code in <code>pyjas/v1_1/jsonapi_builder.py</code> <pre><code>class JSONAPIObject(BaseModel):\n    \"\"\"JSONAPIObject enforces the JSON:API version in a JSON:API document.\n\n    Refer to https://jsonapi.org/format/#document-jsonapi-object for more information.\n\n    Required fields:\n        version (str): The JSON:API version. Default is '1.1'.\n\n    Optional fields:\n        meta (dict): a meta object containing non-standard meta-information about the JSON:API document.\n\n    Raises:\n        ValueError: ensure 'version' is one of the allowed JSON:API versions.\n    \"\"\"\n\n    version: str = '1.1'\n    meta: dict[str, Any] | None = None\n\n    @field_validator('version')\n    @classmethod\n    def must_have_correct_version(cls, v: str) -&gt; Any:\n        \"\"\"Validate the 'version' field according to the JSON:API spec.\"\"\"\n        if v not in ALLOWED_JSONAPI_VERSIONS:\n            raise ValueError(f\"JSONAPI 'version' must be one of {ALLOWED_JSONAPI_VERSIONS}.\")\n        return v\n</code></pre>"},{"location":"api/api-reference/#pyjas.v1_1.jsonapi_builder.JSONAPIObject.must_have_correct_version","title":"<code>must_have_correct_version(v)</code>  <code>classmethod</code>","text":"<p>Validate the 'version' field according to the JSON:API spec.</p> Source code in <code>pyjas/v1_1/jsonapi_builder.py</code> <pre><code>@field_validator('version')\n@classmethod\ndef must_have_correct_version(cls, v: str) -&gt; Any:\n    \"\"\"Validate the 'version' field according to the JSON:API spec.\"\"\"\n    if v not in ALLOWED_JSONAPI_VERSIONS:\n        raise ValueError(f\"JSONAPI 'version' must be one of {ALLOWED_JSONAPI_VERSIONS}.\")\n    return v\n</code></pre>"},{"location":"api/api-reference/#pyjas.v1_1.jsonapi_builder.LinkObject","title":"<code>LinkObject</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>LinkObject enforces a link in a JSON:API document.</p> <p>Refer to https://jsonapi.org/format/#auto-id--link-objects for more information.</p> Required fields <p>href (HttpUrl): The URL of the link.</p> Optional fields <p>rel (str): a string indicating the link's relation type. The string MUST be a valid link relation type. describedby (HttpUrl): a link to a description document (e.g. OpenAPI or JSON Schema) for the link target. title (str): a string which serves as a label for the destination of a link such that it can be used as a     human-readable identifier (e.g., a menu entry). type (str): a string indicating the media type of the link's target. hreflang (str | list[str]): a string or an array of strings indicating the language(s) of the link's target.     An array of strings indicates that the link's target is available in multiple languages. Each string     MUST be a valid language tag [RFC5646]. meta (dict): a meta object containing non-standard meta-information about the link.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>href and describedby are invalid URIs.</p> <code>ValueError</code> <p>each hreflang language tag is valid according to RFC 5646.</p> <code>ValueError</code> <p>ensure type and rel fields are strings, if present.</p> Source code in <code>pyjas/v1_1/jsonapi_builder.py</code> <pre><code>class LinkObject(BaseModel):\n    \"\"\"LinkObject enforces a link in a JSON:API document.\n\n    Refer to https://jsonapi.org/format/#auto-id--link-objects for more information.\n\n    Required fields:\n        href (HttpUrl): The URL of the link.\n\n    Optional fields:\n        rel (str): a string indicating the link's relation type. The string MUST be a valid link relation type.\n        describedby (HttpUrl): a link to a description document (e.g. OpenAPI or JSON Schema) for the link target.\n        title (str): a string which serves as a label for the destination of a link such that it can be used as a\n            human-readable identifier (e.g., a menu entry).\n        type (str): a string indicating the media type of the link's target.\n        hreflang (str | list[str]): a string or an array of strings indicating the language(s) of the link's target.\n            An array of strings indicates that the link's target is available in multiple languages. Each string\n            MUST be a valid language tag [RFC5646].\n        meta (dict): a meta object containing non-standard meta-information about the link.\n\n    Raises:\n        ValueError: href and describedby are invalid URIs.\n        ValueError: each hreflang language tag is valid according to RFC 5646.\n        ValueError: ensure type and rel fields are strings, if present.\n    \"\"\"\n\n    model_config = ConfigDict(extra='forbid')\n\n    href: HttpUrl\n    rel: NonEmptyStr | None = None\n    describedby: HttpUrl | None = None\n    title: NonEmptyStr | None = None\n    type_: NonEmptyStr | None = Field(None, alias='type')\n    hreflang: Annotated[list[NonEmptyStr], conlist(NonEmptyStr, min_length=1)] | NonEmptyStr | None = None\n    meta: dict[str, Any] | None = None\n\n    @model_validator(mode='after')\n    def validate_link_object(self) -&gt; LinkObject:\n        \"\"\"Validate the LinkObject according to the JSON:API spec.\"\"\"\n        # If 'rel' is present, ensure it's a valid relation type (simple string validation)\n        if self.rel is not None and bool(self.rel):\n            if not isinstance(self.rel, str):\n                raise ValueError(\"'rel' must be a string indicating the link's relation type.\")\n            if not self.rel.isalnum():\n                raise ValueError(\"'rel' must be a valid link relation type (alphanumeric characters only).\")\n\n        # hreflang: a string or an array of strings indicating the language(s) of the\n        # link's target. An array of strings indicates that the link's target is available\n        # in multiple languages. Each string MUST be a valid language tag [RFC5646].\n        if self.hreflang is not None:\n            if not bool(self.hreflang) and isinstance(self.hreflang, list | str):\n                raise ValueError(\"'hreflang' must be a non-empty string or a list of non-empty strings.\")\n            elif isinstance(self.hreflang, str) and not self._is_valid_language_tag(self.hreflang):\n                raise ValueError(f\"'hreflang' must be a valid language tag. Got: {self.hreflang}\")\n            elif isinstance(self.hreflang, list):\n                if len(self.hreflang) == 0:\n                    raise ValueError(\"'hreflang' must be a non-empty list of language tags.\")\n                for lang in self.hreflang:\n                    if not isinstance(lang, str):\n                        raise ValueError(f\"Each 'hreflang' entry must be a string. Got: {lang}\")\n                    if not self._is_valid_language_tag(lang):\n                        raise ValueError(f\"'hreflang' must be a valid language tag. Got: {lang}\")\n            elif not isinstance(self.hreflang, str | list):\n                raise ValueError(\"'hreflang' must be a string or a list of strings.\")\n\n        return self\n\n    @staticmethod\n    def _is_valid_language_tag(tag: str) -&gt; bool:\n        \"\"\"Validate that the language tag conforms to RFC 5646.\n\n        Ref: https://stackoverflow.com/a/38959322\n        \"\"\"\n        # Simple regex for basic language tags (not exhaustive)\n        pattern = re.compile(r'^[a-zA-Z]{2,3}(-[a-zA-Z]{2,4})?$')\n        return bool(pattern.match(tag))\n</code></pre>"},{"location":"api/api-reference/#pyjas.v1_1.jsonapi_builder.LinkObject.validate_link_object","title":"<code>validate_link_object()</code>","text":"<p>Validate the LinkObject according to the JSON:API spec.</p> Source code in <code>pyjas/v1_1/jsonapi_builder.py</code> <pre><code>@model_validator(mode='after')\ndef validate_link_object(self) -&gt; LinkObject:\n    \"\"\"Validate the LinkObject according to the JSON:API spec.\"\"\"\n    # If 'rel' is present, ensure it's a valid relation type (simple string validation)\n    if self.rel is not None and bool(self.rel):\n        if not isinstance(self.rel, str):\n            raise ValueError(\"'rel' must be a string indicating the link's relation type.\")\n        if not self.rel.isalnum():\n            raise ValueError(\"'rel' must be a valid link relation type (alphanumeric characters only).\")\n\n    # hreflang: a string or an array of strings indicating the language(s) of the\n    # link's target. An array of strings indicates that the link's target is available\n    # in multiple languages. Each string MUST be a valid language tag [RFC5646].\n    if self.hreflang is not None:\n        if not bool(self.hreflang) and isinstance(self.hreflang, list | str):\n            raise ValueError(\"'hreflang' must be a non-empty string or a list of non-empty strings.\")\n        elif isinstance(self.hreflang, str) and not self._is_valid_language_tag(self.hreflang):\n            raise ValueError(f\"'hreflang' must be a valid language tag. Got: {self.hreflang}\")\n        elif isinstance(self.hreflang, list):\n            if len(self.hreflang) == 0:\n                raise ValueError(\"'hreflang' must be a non-empty list of language tags.\")\n            for lang in self.hreflang:\n                if not isinstance(lang, str):\n                    raise ValueError(f\"Each 'hreflang' entry must be a string. Got: {lang}\")\n                if not self._is_valid_language_tag(lang):\n                    raise ValueError(f\"'hreflang' must be a valid language tag. Got: {lang}\")\n        elif not isinstance(self.hreflang, str | list):\n            raise ValueError(\"'hreflang' must be a string or a list of strings.\")\n\n    return self\n</code></pre>"},{"location":"api/api-reference/#pyjas.v1_1.jsonapi_builder.RelationshipObject","title":"<code>RelationshipObject</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>RelationshipObject enforces a relationship in a JSON:API document.</p> <p>Refer to https://jsonapi.org/format/#document-resource-object-relationships for more information.</p> <p>Please note that extra members are allowed in the RelationshipObject.</p> Optional fields <p>links (dict): a links object containing links related to the resource. data (ResourceIdentifierObject | list[ResourceIdentifierObject]): resource linkage. meta (dict): a meta object containing non-standard meta-information about the relationship.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>ensure at least one of 'links', 'data', or 'meta' is present.</p> Source code in <code>pyjas/v1_1/jsonapi_builder.py</code> <pre><code>class RelationshipObject(BaseModel):\n    \"\"\"RelationshipObject enforces a relationship in a JSON:API document.\n\n    Refer to https://jsonapi.org/format/#document-resource-object-relationships for more information.\n\n    Please note that extra members are allowed in the RelationshipObject.\n\n    Optional fields:\n        links (dict): a links object containing links related to the resource.\n        data (ResourceIdentifierObject | list[ResourceIdentifierObject]): resource linkage.\n        meta (dict): a meta object containing non-standard meta-information about the relationship.\n\n    Raises:\n        ValueError: ensure at least one of 'links', 'data', or 'meta' is present.\n    \"\"\"\n\n    model_config = ConfigDict(extra='allow')\n\n    links: dict[str, LinkValue] | None = None\n    data: ResourceIdentifierObject | list[ResourceIdentifierObject] | None = None\n    meta: dict[str, Any] | None = None\n\n    @model_validator(mode='after')\n    def validate_relationship(self) -&gt; RelationshipObject:\n        \"\"\"Validate the RelationshipObject according to the JSON:API spec.\"\"\"\n        if not self.links and not self.data and not self.meta:\n            raise ValueError(\"RelationshipObject must contain at least one of 'links', 'data', or 'meta'.\")\n\n        # Validate links if present\n        if self.links:\n            allowed_links = {'self', 'related', 'describedby'}\n            for link_key, link_value in self.links.items():\n                if link_key not in allowed_links:\n                    raise ValueError(\n                        f\"Invalid link key '{link_key}' in RelationshipObject. Allowed keys: {allowed_links}.\"\n                    )\n                if link_value is not None and not isinstance(link_value, str | LinkObject):\n                    raise ValueError(f\"Link '{link_key}' must be a string URI, LinkObject, or null.\")\n                if isinstance(link_value, str) and not is_valid_uri(link_value):\n                    raise ValueError(f\"Link '{link_key}' must be a valid URI-reference.\")\n\n        # Validate data linkage\n        if self.data:\n            if isinstance(self.data, list):\n                for item in self.data:\n                    if not isinstance(item, ResourceIdentifierObject):\n                        raise ValueError(\"All items in 'data' must be ResourceIdentifierObject instances.\")\n            elif not isinstance(self.data, ResourceIdentifierObject):\n                raise ValueError(\n                    \"'data' must be a ResourceIdentifierObject or a list of ResourceIdentifierObject instances.\"\n                )\n\n        # Validate member names if extra members are present\n        extra_members = self.model_fields_set - set(self.model_fields.keys())\n        if extra_members:\n            for member_name in extra_members:\n                validate_member_name(member_name)\n\n        return self\n</code></pre>"},{"location":"api/api-reference/#pyjas.v1_1.jsonapi_builder.RelationshipObject.validate_relationship","title":"<code>validate_relationship()</code>","text":"<p>Validate the RelationshipObject according to the JSON:API spec.</p> Source code in <code>pyjas/v1_1/jsonapi_builder.py</code> <pre><code>@model_validator(mode='after')\ndef validate_relationship(self) -&gt; RelationshipObject:\n    \"\"\"Validate the RelationshipObject according to the JSON:API spec.\"\"\"\n    if not self.links and not self.data and not self.meta:\n        raise ValueError(\"RelationshipObject must contain at least one of 'links', 'data', or 'meta'.\")\n\n    # Validate links if present\n    if self.links:\n        allowed_links = {'self', 'related', 'describedby'}\n        for link_key, link_value in self.links.items():\n            if link_key not in allowed_links:\n                raise ValueError(\n                    f\"Invalid link key '{link_key}' in RelationshipObject. Allowed keys: {allowed_links}.\"\n                )\n            if link_value is not None and not isinstance(link_value, str | LinkObject):\n                raise ValueError(f\"Link '{link_key}' must be a string URI, LinkObject, or null.\")\n            if isinstance(link_value, str) and not is_valid_uri(link_value):\n                raise ValueError(f\"Link '{link_key}' must be a valid URI-reference.\")\n\n    # Validate data linkage\n    if self.data:\n        if isinstance(self.data, list):\n            for item in self.data:\n                if not isinstance(item, ResourceIdentifierObject):\n                    raise ValueError(\"All items in 'data' must be ResourceIdentifierObject instances.\")\n        elif not isinstance(self.data, ResourceIdentifierObject):\n            raise ValueError(\n                \"'data' must be a ResourceIdentifierObject or a list of ResourceIdentifierObject instances.\"\n            )\n\n    # Validate member names if extra members are present\n    extra_members = self.model_fields_set - set(self.model_fields.keys())\n    if extra_members:\n        for member_name in extra_members:\n            validate_member_name(member_name)\n\n    return self\n</code></pre>"},{"location":"api/api-reference/#pyjas.v1_1.jsonapi_builder.ResourceIdentifierObject","title":"<code>ResourceIdentifierObject</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>ResourceIdentifierObject enforces a resource identifier in a JSON:API document.</p> <p>Refer to https://jsonapi.org/format/#auto-id--link-objects for more information. Note that extra members are allowed in the ResourceIdentifierObject.</p> Required fields <p>type (NonEmptyStr): The type of the resource.</p> Optional fields <p>id (NonEmptyStr): The id of the resource. lid (NonEmptyStr): A locally unique identifier for the resource. meta (dict): a meta object containing non-standard meta-information about the resource.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>ensure at least 'id' or 'lid' are present.</p> <code>ValueError</code> <p>ensure 'type' is a string.</p> <code>ValueError</code> <p>ensure 'id' and 'lid' are strings, if present.</p> Source code in <code>pyjas/v1_1/jsonapi_builder.py</code> <pre><code>class ResourceIdentifierObject(BaseModel):\n    \"\"\"ResourceIdentifierObject enforces a resource identifier in a JSON:API document.\n\n    Refer to https://jsonapi.org/format/#auto-id--link-objects for more information.\n    Note that extra members are allowed in the ResourceIdentifierObject.\n\n    Required fields:\n        type (NonEmptyStr): The type of the resource.\n\n    Optional fields:\n        id (NonEmptyStr): The id of the resource.\n        lid (NonEmptyStr): A locally unique identifier for the resource.\n        meta (dict): a meta object containing non-standard meta-information about the resource.\n\n    Raises:\n        ValueError: ensure at least 'id' or 'lid' are present.\n        ValueError: ensure 'type' is a string.\n        ValueError: ensure 'id' and 'lid' are strings, if present.\n    \"\"\"\n\n    model_config = ConfigDict(extra='forbid')\n\n    type_: NonEmptyStr = Field(..., alias='type')\n    id_: NonEmptyStr | None = Field(None, alias='id')\n    lid: NonEmptyStr | None = None\n    meta: dict[str, Any] | None = None\n\n    @model_validator(mode='after')\n    def validate_id_or_lid(self) -&gt; ResourceIdentifierObject:\n        \"\"\"Check that the ResourceIdentifierObject has either id or lid.\"\"\"\n        if not self.id_ and not self.lid:\n            raise ValueError(\"ResourceIdentifierObject must have either 'id' or 'lid'.\")\n\n        # Ensure type_ is a string\n        if not isinstance(self.type_, str) and not bool(self.type_):\n            raise ValueError(\"'type' must be a string.\")\n\n        # Ensure id_ and lid, if present, are strings\n        if self.id_ is not None and isinstance(self.id_, str) and not bool(self.id_):\n            raise ValueError(\"'id' must be a string.\")\n        if self.lid is not None and isinstance(self.lid, str) and not bool(self.lid):\n            raise ValueError(\"'lid' must be a string.\")\n\n        return self\n</code></pre>"},{"location":"api/api-reference/#pyjas.v1_1.jsonapi_builder.ResourceIdentifierObject.validate_id_or_lid","title":"<code>validate_id_or_lid()</code>","text":"<p>Check that the ResourceIdentifierObject has either id or lid.</p> Source code in <code>pyjas/v1_1/jsonapi_builder.py</code> <pre><code>@model_validator(mode='after')\ndef validate_id_or_lid(self) -&gt; ResourceIdentifierObject:\n    \"\"\"Check that the ResourceIdentifierObject has either id or lid.\"\"\"\n    if not self.id_ and not self.lid:\n        raise ValueError(\"ResourceIdentifierObject must have either 'id' or 'lid'.\")\n\n    # Ensure type_ is a string\n    if not isinstance(self.type_, str) and not bool(self.type_):\n        raise ValueError(\"'type' must be a string.\")\n\n    # Ensure id_ and lid, if present, are strings\n    if self.id_ is not None and isinstance(self.id_, str) and not bool(self.id_):\n        raise ValueError(\"'id' must be a string.\")\n    if self.lid is not None and isinstance(self.lid, str) and not bool(self.lid):\n        raise ValueError(\"'lid' must be a string.\")\n\n    return self\n</code></pre>"},{"location":"api/api-reference/#pyjas.v1_1.jsonapi_builder.ResourceObject","title":"<code>ResourceObject</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>ResourceObject enforces a resource object in a JSON:API document.</p> <p>Refer to https://jsonapi.org/format/#document-resource-objects for more information. Note that extra members are not allowed in the ResourceObject.</p> Required fields <p>type (str): The type of the resource.</p> Optional fields <p>id (str): The id of the resource. lid (str): A locally unique identifier for the resource. attributes (dict): an attributes object representing some of the resource's data. relationships (dict): a relationships object describing relationships between the resource and other resources. links (dict): a links object containing links related to the resource. meta (dict): a meta object containing non-standard meta-information about the resource.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>ensure 'type' is a string.</p> <code>ValueError</code> <p>ensure either 'id' or 'lid' is present.</p> <code>ValueError</code> <p>ensure 'id' or 'lid' are strings, if present.</p> <code>ValueError</code> <p>ensure no field name conflicts between attributes and relationships.</p> <code>ValueError</code> <p>ensure attribute keys do not include 'type', 'id', 'lid'.</p> <code>ValueError</code> <p>ensure relationship keys do not include 'type', 'id', 'lid'.</p> <code>ValueError</code> <p>ensure no foreign keys in attributes (e.g., 'author_id').</p> <code>ValueError</code> <p>ensure all included resources are reachable from primary data.</p> <code>ValueError</code> <p>ensure all included resources are unique.</p> <code>ValueError</code> <p>ensure all included resources are linked from primary data.</p> <code>ValueError</code> <p>ensure links are valid URIs.</p> <code>ValueError</code> <p>ensure links are valid LinkObjects.</p> <code>ValueError</code> <p>ensure links are valid keys ('self', 'related', 'describedby', 'pagination').</p> <code>ValueError</code> <p>ensure 'lid' is unique within the document.</p> Source code in <code>pyjas/v1_1/jsonapi_builder.py</code> <pre><code>class ResourceObject(BaseModel):\n    \"\"\"ResourceObject enforces a resource object in a JSON:API document.\n\n    Refer to https://jsonapi.org/format/#document-resource-objects for more information.\n    Note that extra members are not allowed in the ResourceObject.\n\n    Required fields:\n        type (str): The type of the resource.\n\n    Optional fields:\n        id (str): The id of the resource.\n        lid (str): A locally unique identifier for the resource.\n        attributes (dict): an attributes object representing some of the resource's data.\n        relationships (dict): a relationships object describing relationships between the resource and other resources.\n        links (dict): a links object containing links related to the resource.\n        meta (dict): a meta object containing non-standard meta-information about the resource.\n\n    Raises:\n        ValueError: ensure 'type' is a string.\n        ValueError: ensure either 'id' or 'lid' is present.\n        ValueError: ensure 'id' or 'lid' are strings, if present.\n        ValueError: ensure no field name conflicts between attributes and relationships.\n        ValueError: ensure attribute keys do not include 'type', 'id', 'lid'.\n        ValueError: ensure relationship keys do not include 'type', 'id', 'lid'.\n        ValueError: ensure no foreign keys in attributes (e.g., 'author_id').\n        ValueError: ensure all included resources are reachable from primary data.\n        ValueError: ensure all included resources are unique.\n        ValueError: ensure all included resources are linked from primary data.\n        ValueError: ensure links are valid URIs.\n        ValueError: ensure links are valid LinkObjects.\n        ValueError: ensure links are valid keys ('self', 'related', 'describedby', 'pagination').\n        ValueError: ensure 'lid' is unique within the document.\n    \"\"\"\n\n    model_config = ConfigDict(extra='forbid')\n\n    type_: NonEmptyStr = Field(..., alias='type')\n    id_: NonEmptyStr | None = Field(None, alias='id')\n    lid: NonEmptyStr | None = None\n    attributes: dict[str, Any] | None = None\n    relationships: dict[str, RelationshipObject] | None = None\n    links: dict[str, LinkValue] | None = None\n    meta: dict[str, Any] | None = None\n\n    @model_validator(mode='after')\n    def validate_resource_object(self) -&gt; ResourceObject:\n        \"\"\"Validate the ResourceObject according to the JSON:API spec.\"\"\"\n        # Ensure type_ is a string\n        if not isinstance(self.type_, str) or not bool(self.type_):\n            raise ValueError(\"'type' must be a string.\")\n\n        # Ensure id_ and lid, if present, are strings\n        if self.id_ is not None and isinstance(self.id_, str) and not bool(self.id_):\n            raise ValueError(\"'id' must be a string.\")\n        if self.lid is not None and isinstance(self.lid, str) and not bool(self.lid):\n            raise ValueError(\"'lid' must be a string.\")\n\n        # Either id or lid must be present\n        if (not self.id_ or not bool(self.id_)) and (not self.lid or not bool(self.lid)):\n            raise ValueError(\"ResourceObject must have either 'id' or 'lid'.\")\n\n        # Ensure no field name conflicts\n        if self.attributes and self.relationships:\n            attribute_keys = set(self.attributes.keys())\n            relationship_keys = set(self.relationships.keys())\n            common_keys = attribute_keys.intersection(relationship_keys)\n            reserved_keys = {'type', 'id', 'lid'}\n            conflicting_reserved_keys = common_keys.intersection(reserved_keys)\n            if conflicting_reserved_keys:\n                raise ValueError(\n                    f'Fields {conflicting_reserved_keys} are reserved and cannot be used as attribute or relationship names.'  # noqa: E501\n                )\n            if common_keys:\n                raise ValueError(\n                    f'Attribute and relationship names must not conflict. Conflicting names: {common_keys}'\n                )\n\n        # Validate attributes\n        if self.attributes:\n            # Ensure attribute keys do not include 'type', 'id', 'lid'\n            reserved_keys = {'type', 'id', 'lid'}\n            attribute_keys = set(self.attributes.keys())\n            if reserved_keys.intersection(attribute_keys):\n                raise ValueError(\n                    f'Attribute names {reserved_keys.intersection(attribute_keys)} are reserved and cannot be used.'\n                )\n\n            # Enforce that attribute keys do not contain foreign keys (e.g., 'author_id')\n            foreign_keys = {key for key in attribute_keys if key.endswith('_id')}\n            if foreign_keys:\n                raise ValueError(\n                    f'Attribute names {foreign_keys} are reserved for relationships and should not appear in attributes.'  # noqa: E501\n                )\n\n        # Validate relationships\n        if self.relationships:\n            # Ensure relationship keys do not include 'type', 'id', 'lid'\n            reserved_keys = {'type', 'id', 'lid'}\n            relationship_keys = set(self.relationships.keys())\n            if reserved_keys.intersection(relationship_keys):\n                raise ValueError(\n                    f'Relationship names {reserved_keys.intersection(relationship_keys)} are reserved and cannot be used.'  # noqa: E501\n                )\n\n        # Validate links if present\n        if self.links:\n            allowed_links = {'self', 'related', 'describedby', 'pagination'}\n            for link_key, link_value in self.links.items():\n                if link_key not in allowed_links:\n                    raise ValueError(f\"Invalid link key '{link_key}' in ResourceObject. Allowed keys: {allowed_links}.\")\n                if link_value is not None and not isinstance(link_value, str | LinkObject):\n                    raise ValueError(f\"Link '{link_key}' must be a string URI, LinkObject, or null.\")\n                if isinstance(link_value, str) and not is_valid_uri(link_value):\n                    raise ValueError(f\"Link '{link_key}' must be a valid URI-reference.\")\n                if isinstance(link_value, LinkObject):\n                    link_value = LinkObject(**link_value.dict())  # Ensure LinkObject validation\n\n        return self\n\n    @classmethod\n    def from_model(\n        cls,\n        model: BaseModel,\n        type_: str | None = None,\n        id_: str | None = None,\n        relationships: dict[str, RelationshipObject] | None = None,\n        links: dict[str, Any] | None = None,\n        meta: dict[str, Any] | None = None,\n        lid_registry: dict[Any, str] | None = None,\n    ) -&gt; ResourceObject:\n        \"\"\"Create a ResourceObject from a Pydantic BaseModel instance.\"\"\"\n\n        if lid_registry is None:\n            lid_registry = {}\n\n        # Get 'id' and 'type' from the model if not provided\n        if id_ is None and hasattr(model, 'id'):\n            id_ = str(model.id)\n\n        if type_ is None and hasattr(model, '__type__'):\n            type_ = model.__type__\n\n        if type_ is None:\n            raise ValueError(\n                \"Resource 'type' must be provided either as a parameter or via '__type__' attribute in the model.\"\n            )\n\n        # Extract attributes from the model, excluding 'id' and 'type' if present\n        exclude_fields = {'id', 'type'} if hasattr(model, 'type') else {'id'}\n        attributes = model.model_dump(exclude=exclude_fields)\n\n        # Generate or retrieve 'lid' if 'id' is not available\n        lid = None\n        if id_ is None:\n            model_id = id(model)  # Use the unique id of the model instance\n            if model_id in lid_registry:\n                lid = lid_registry[model_id]\n            else:\n                # Generate a new 'lid' and store it in the registry\n                lid = str(uuid.uuid4())\n                lid_registry[model_id] = lid\n\n        return cls(\n            type=type_,\n            id=id_,\n            lid=lid,\n            attributes=attributes if attributes else None,\n            relationships=relationships,\n            links=links,\n            meta=meta,\n        )\n</code></pre>"},{"location":"api/api-reference/#pyjas.v1_1.jsonapi_builder.ResourceObject.from_model","title":"<code>from_model(model, type_=None, id_=None, relationships=None, links=None, meta=None, lid_registry=None)</code>  <code>classmethod</code>","text":"<p>Create a ResourceObject from a Pydantic BaseModel instance.</p> Source code in <code>pyjas/v1_1/jsonapi_builder.py</code> <pre><code>@classmethod\ndef from_model(\n    cls,\n    model: BaseModel,\n    type_: str | None = None,\n    id_: str | None = None,\n    relationships: dict[str, RelationshipObject] | None = None,\n    links: dict[str, Any] | None = None,\n    meta: dict[str, Any] | None = None,\n    lid_registry: dict[Any, str] | None = None,\n) -&gt; ResourceObject:\n    \"\"\"Create a ResourceObject from a Pydantic BaseModel instance.\"\"\"\n\n    if lid_registry is None:\n        lid_registry = {}\n\n    # Get 'id' and 'type' from the model if not provided\n    if id_ is None and hasattr(model, 'id'):\n        id_ = str(model.id)\n\n    if type_ is None and hasattr(model, '__type__'):\n        type_ = model.__type__\n\n    if type_ is None:\n        raise ValueError(\n            \"Resource 'type' must be provided either as a parameter or via '__type__' attribute in the model.\"\n        )\n\n    # Extract attributes from the model, excluding 'id' and 'type' if present\n    exclude_fields = {'id', 'type'} if hasattr(model, 'type') else {'id'}\n    attributes = model.model_dump(exclude=exclude_fields)\n\n    # Generate or retrieve 'lid' if 'id' is not available\n    lid = None\n    if id_ is None:\n        model_id = id(model)  # Use the unique id of the model instance\n        if model_id in lid_registry:\n            lid = lid_registry[model_id]\n        else:\n            # Generate a new 'lid' and store it in the registry\n            lid = str(uuid.uuid4())\n            lid_registry[model_id] = lid\n\n    return cls(\n        type=type_,\n        id=id_,\n        lid=lid,\n        attributes=attributes if attributes else None,\n        relationships=relationships,\n        links=links,\n        meta=meta,\n    )\n</code></pre>"},{"location":"api/api-reference/#pyjas.v1_1.jsonapi_builder.ResourceObject.validate_resource_object","title":"<code>validate_resource_object()</code>","text":"<p>Validate the ResourceObject according to the JSON:API spec.</p> Source code in <code>pyjas/v1_1/jsonapi_builder.py</code> <pre><code>@model_validator(mode='after')\ndef validate_resource_object(self) -&gt; ResourceObject:\n    \"\"\"Validate the ResourceObject according to the JSON:API spec.\"\"\"\n    # Ensure type_ is a string\n    if not isinstance(self.type_, str) or not bool(self.type_):\n        raise ValueError(\"'type' must be a string.\")\n\n    # Ensure id_ and lid, if present, are strings\n    if self.id_ is not None and isinstance(self.id_, str) and not bool(self.id_):\n        raise ValueError(\"'id' must be a string.\")\n    if self.lid is not None and isinstance(self.lid, str) and not bool(self.lid):\n        raise ValueError(\"'lid' must be a string.\")\n\n    # Either id or lid must be present\n    if (not self.id_ or not bool(self.id_)) and (not self.lid or not bool(self.lid)):\n        raise ValueError(\"ResourceObject must have either 'id' or 'lid'.\")\n\n    # Ensure no field name conflicts\n    if self.attributes and self.relationships:\n        attribute_keys = set(self.attributes.keys())\n        relationship_keys = set(self.relationships.keys())\n        common_keys = attribute_keys.intersection(relationship_keys)\n        reserved_keys = {'type', 'id', 'lid'}\n        conflicting_reserved_keys = common_keys.intersection(reserved_keys)\n        if conflicting_reserved_keys:\n            raise ValueError(\n                f'Fields {conflicting_reserved_keys} are reserved and cannot be used as attribute or relationship names.'  # noqa: E501\n            )\n        if common_keys:\n            raise ValueError(\n                f'Attribute and relationship names must not conflict. Conflicting names: {common_keys}'\n            )\n\n    # Validate attributes\n    if self.attributes:\n        # Ensure attribute keys do not include 'type', 'id', 'lid'\n        reserved_keys = {'type', 'id', 'lid'}\n        attribute_keys = set(self.attributes.keys())\n        if reserved_keys.intersection(attribute_keys):\n            raise ValueError(\n                f'Attribute names {reserved_keys.intersection(attribute_keys)} are reserved and cannot be used.'\n            )\n\n        # Enforce that attribute keys do not contain foreign keys (e.g., 'author_id')\n        foreign_keys = {key for key in attribute_keys if key.endswith('_id')}\n        if foreign_keys:\n            raise ValueError(\n                f'Attribute names {foreign_keys} are reserved for relationships and should not appear in attributes.'  # noqa: E501\n            )\n\n    # Validate relationships\n    if self.relationships:\n        # Ensure relationship keys do not include 'type', 'id', 'lid'\n        reserved_keys = {'type', 'id', 'lid'}\n        relationship_keys = set(self.relationships.keys())\n        if reserved_keys.intersection(relationship_keys):\n            raise ValueError(\n                f'Relationship names {reserved_keys.intersection(relationship_keys)} are reserved and cannot be used.'  # noqa: E501\n            )\n\n    # Validate links if present\n    if self.links:\n        allowed_links = {'self', 'related', 'describedby', 'pagination'}\n        for link_key, link_value in self.links.items():\n            if link_key not in allowed_links:\n                raise ValueError(f\"Invalid link key '{link_key}' in ResourceObject. Allowed keys: {allowed_links}.\")\n            if link_value is not None and not isinstance(link_value, str | LinkObject):\n                raise ValueError(f\"Link '{link_key}' must be a string URI, LinkObject, or null.\")\n            if isinstance(link_value, str) and not is_valid_uri(link_value):\n                raise ValueError(f\"Link '{link_key}' must be a valid URI-reference.\")\n            if isinstance(link_value, LinkObject):\n                link_value = LinkObject(**link_value.dict())  # Ensure LinkObject validation\n\n    return self\n</code></pre>"},{"location":"api/api-reference/#pyjas.v1_1.jsonapi_builder.validate_member_name","title":"<code>validate_member_name(name)</code>","text":"<p>Validates a JSON:API member name according to the specification rules.</p> <p>Refer to https://jsonapi.org/format/#document-member-names for more information.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The member name to validate.</p> required <p>Raises:</p> Type Description <code>ValueError</code> <p>If the member name does not comply with the rules.</p> Source code in <code>pyjas/v1_1/jsonapi_builder.py</code> <pre><code>def validate_member_name(name: str) -&gt; None:\n    \"\"\"Validates a JSON:API member name according to the specification rules.\n\n    Refer to https://jsonapi.org/format/#document-member-names for more information.\n\n    Args:\n        name (str): The member name to validate.\n\n    Raises:\n        ValueError: If the member name does not comply with the rules.\n    \"\"\"\n    if not isinstance(name, str):\n        raise ValueError('Member name must be a string.')\n\n    if len(name) == 0:\n        raise ValueError('Member name must contain at least one character.')\n\n    # Reserved characters (must not be present)\n    reserved_characters = set(\n        '+,.,[,],!,\",#,,$,%,&amp;,\\',(,),*,/,:,;,&lt;,=,&gt;,?,\\\\,^,`,{,|,},~,DEL'\n    )  # 'DEL' represents U+007F\n    # Note: 'DEL' is non-printable; in practice, it's handled by character ranges.\n\n    # Define allowed characters using regex\n    # Globally allowed: a-z, A-Z, 0-9, and U+0080+\n    # Internal allowed: -, _, space\n    # Extension members start with namespace followed by colon\n\n    # Regex patterns\n    # Pattern for the core allowed characters (excluding @-Members and extension members)\n    core_pattern = r'^[A-Za-z0-9\\u0080-\\uFFFF](?:[A-Za-z0-9\\u0080-\\uFFFF\\-_\\ ]*[A-Za-z0-9\\u0080-\\uFFFF])?$'\n\n    # Pattern for @-Members\n    at_member_pattern = r'^@[A-Za-z0-9\\u0080-\\uFFFF](?:[A-Za-z0-9\\u0080-\\uFFFF\\-_\\ ]*[A-Za-z0-9\\u0080-\\uFFFF])?$'\n\n    # Pattern for Extension Members (namespace:member)\n    extension_pattern = r'^[A-Za-z0-9\\u0080-\\uFFFF]+:[A-Za-z0-9\\u0080-\\uFFFF](?:[A-Za-z0-9\\u0080-\\uFFFF\\-_\\ ]*[A-Za-z0-9\\u0080-\\uFFFF])?$'  # noqa: E501\n\n    if re.match(core_pattern, name):\n        pass  # Valid core member name\n    elif re.match(at_member_pattern, name):\n        pass  # Valid @-Member\n    elif re.match(extension_pattern, name):\n        pass  # Valid Extension Member\n    else:\n        raise ValueError(f\"Invalid member name '{name}' according to JSON:API specification.\")\n\n    # Check for reserved characters\n    for char in name:\n        if char in reserved_characters:\n            raise ValueError(f\"Member name '{name}' contains reserved character '{char}' which is not allowed.\")\n</code></pre>"},{"location":"examples/simple-usage/","title":"FastAPI JSONAPI with Supabase Example","text":"<p>In this example, we'll create a simple FastAPI application that adheres to the JSON:API specification using PyJAS. We'll connect the API to a Supabase PostgreSQL database to handle data storage.</p>"},{"location":"examples/simple-usage/#prerequisites","title":"Prerequisites","text":"<ul> <li>Python 3.10+</li> <li>Supabase account and project</li> <li><code>pip</code> package manager</li> </ul>"},{"location":"examples/simple-usage/#setup","title":"Setup","text":""},{"location":"examples/simple-usage/#1-install-dependencies","title":"1. Install Dependencies","text":"<p>First, install the required Python packages:</p> <pre><code>pip install fastapi uvicorn pyjas asyncpg sqlalchemy supabase\n</code></pre>"},{"location":"examples/simple-usage/#2-configure-supabase","title":"2. Configure Supabase","text":"<p>Sign up for a Supabase account and create a new project. Note down the API URL and API Key from your Supabase project settings.</p> <p>Create a table named <code>articles</code> with the following schema:</p> <ul> <li><code>id</code>: UUID (Primary Key)</li> <li><code>title</code>: Text</li> <li><code>content</code>: Text</li> <li><code>created_at</code>: Timestamp</li> </ul>"},{"location":"examples/simple-usage/#3-server-side-code","title":"3. Server-Side Code","text":"<p>Create a file named <code>main.py</code> and add the following code:</p> <pre><code>from fastapi import FastAPI, HTTPException\nfrom pyjas.v1_1 import Document, ResourceObject, JSONAPIObject\nfrom pydantic import BaseModel, Field\nfrom typing import Optional, List\nimport uuid\nimport asyncpg\nimport os\n\n# Configuration\nDATABASE_URL = os.getenv(\"SUPABASE_DATABASE_URL\")  # e.g., \"postgresql://user:password@host:port/dbname\"\n\n# Pydantic Models\n\nclass ArticleAttributes(BaseModel):\n    title: str\n    content: str\n\nclass Article(ResourceObject):\n    type_: str = Field(\"articles\", alias=\"type\")\n    id_: Optional[str] = Field(None, alias=\"id\")\n    attributes: ArticleAttributes\n\n# Initialize FastAPI\napp = FastAPI()\n\n# Database connection pool\n@app.on_event(\"startup\")\nasync def startup():\n    app.state.pool = await asyncpg.create_pool(DATABASE_URL)\n\n@app.on_event(\"shutdown\")\nasync def shutdown():\n    await app.state.pool.close()\n\n# Create Article\n@app.post(\"/articles\", response_model=Document)\nasync def create_article(document: Document):\n    if not isinstance(document.data, Article):\n        raise HTTPException(status_code=400, detail=\"Invalid data\")\n    article: Article = document.data\n    article_id = str(uuid.uuid4())\n    async with app.state.pool.acquire() as conn:\n        await conn.execute(\n            \"\"\"\n            INSERT INTO articles(id, title, content, created_at)\n            VALUES($1, $2, $3, NOW())\n            \"\"\",\n            article_id,\n            article.attributes.title,\n            article.attributes.content\n        )\n    article.id_ = article_id\n    return Document(data=article)\n\n# Get Article\n@app.get(\"/articles/{article_id}\", response_model=Document)\nasync def get_article(article_id: str):\n    async with app.state.pool.acquire() as conn:\n        row = await conn.fetchrow(\n            \"SELECT id, title, content FROM articles WHERE id = $1\", article_id\n        )\n        if not row:\n            raise HTTPException(status_code=404, detail=\"Article not found\")\n        article = Article(\n            id_=row[\"id\"],\n            attributes=ArticleAttributes(title=row[\"title\"], content=row[\"content\"])\n        )\n        return Document(data=article)\n\n# List Articles\n@app.get(\"/articles\", response_model=Document)\nasync def list_articles():\n    async with app.state.pool.acquire() as conn:\n        rows = await conn.fetch(\"SELECT id, title, content FROM articles\")\n        articles = [\n            Article(\n                id_=row[\"id\"],\n                attributes=ArticleAttributes(title=row[\"title\"], content=row[\"content\"])\n            )\n            for row in rows\n        ]\n        return Document(data=articles)\n\n# Update Article\n@app.patch(\"/articles/{article_id}\", response_model=Document)\nasync def update_article(article_id: str, document: Document):\n    if not isinstance(document.data, Article):\n        raise HTTPException(status_code=400, detail=\"Invalid data\")\n    article: Article = document.data\n    async with app.state.pool.acquire() as conn:\n        result = await conn.execute(\n            \"\"\"\n            UPDATE articles\n            SET title = $1, content = $2\n            WHERE id = $3\n            \"\"\",\n            article.attributes.title,\n            article.attributes.content,\n            article_id\n        )\n        if result == \"UPDATE 0\":\n            raise HTTPException(status_code=404, detail=\"Article not found\")\n    article.id_ = article_id\n    return Document(data=article)\n\n# Delete Article\n@app.delete(\"/articles/{article_id}\", response_model=Document)\nasync def delete_article(article_id: str):\n    async with app.state.pool.acquire() as conn:\n        result = await conn.execute(\n            \"DELETE FROM articles WHERE id = $1\", article_id\n        )\n        if result == \"DELETE 0\":\n            raise HTTPException(status_code=404, detail=\"Article not found\")\n    return Document(data=None)\n\n# JSONAPI Object\n@app.get(\"/jsonapi\", response_model=JSONAPIObject)\nasync def get_jsonapi():\n    return JSONAPIObject()\n</code></pre>"},{"location":"examples/simple-usage/#4-run-the-server","title":"4. Run the Server","text":"<p>Set the <code>SUPABASE_DATABASE_URL</code> environment variable with your Supabase PostgreSQL connection string.</p> <pre><code>export SUPABASE_DATABASE_URL=\"postgresql://user:password@host:port/dbname\"\n</code></pre> <p>Start the FastAPI server using Uvicorn:</p> <pre><code>uvicorn main:app --reload\n</code></pre> <p>The API will be available at <code>http://localhost:8000</code>.</p>"},{"location":"examples/simple-usage/#5-client-side-code","title":"5. Client-Side Code","text":"<p>Here's an example of how to interact with the API using Python's <code>requests</code> library.</p> <pre><code>import requests\nimport json\n\nBASE_URL = \"http://localhost:8000\"\n\n# Create an Article\ndef create_article(title, content):\n    article = {\n        \"data\": {\n            \"type\": \"articles\",\n            \"attributes\": {\n                \"title\": title,\n                \"content\": content\n            }\n        }\n    }\n    response = requests.post(f\"{BASE_URL}/articles\", json=article)\n    return response.json()\n\n# Get an Article\ndef get_article(article_id):\n    response = requests.get(f\"{BASE_URL}/articles/{article_id}\")\n    return response.json()\n\n# List Articles\ndef list_articles():\n    response = requests.get(f\"{BASE_URL}/articles\")\n    return response.json()\n\n# Update an Article\ndef update_article(article_id, title, content):\n    article = {\n        \"data\": {\n            \"type\": \"articles\",\n            \"id\": article_id,\n            \"attributes\": {\n                \"title\": title,\n                \"content\": content\n            }\n        }\n    }\n    response = requests.patch(f\"{BASE_URL}/articles/{article_id}\", json=article)\n    return response.json()\n\n# Delete an Article\ndef delete_article(article_id):\n    response = requests.delete(f\"{BASE_URL}/articles/{article_id}\")\n    return response.json()\n\n# Example Usage\nif __name__ == \"__main__\":\n    # Create a new article\n    new_article = create_article(\"Hello World\", \"This is my first article.\")\n    print(\"Created Article:\", json.dumps(new_article, indent=2))\n\n    article_id = new_article['data']['id']\n\n    # Get the created article\n    article = get_article(article_id)\n    print(\"Retrieved Article:\", json.dumps(article, indent=2))\n\n    # Update the article\n    updated_article = update_article(article_id, \"Hello World Updated\", \"Updated content.\")\n    print(\"Updated Article:\", json.dumps(updated_article, indent=2))\n\n    # List all articles\n    articles = list_articles()\n    print(\"All Articles:\", json.dumps(articles, indent=2))\n\n    # Delete the article\n    delete_response = delete_article(article_id)\n    print(\"Delete Response:\", json.dumps(delete_response, indent=2))\n</code></pre>"},{"location":"examples/simple-usage/#6-testing-the-api","title":"6. Testing the API","text":"<p>You can use tools like Postman or HTTPie to test the API endpoints. Below are example <code>curl</code> commands:</p> <ul> <li> <p>Create an Article:</p> <pre><code>curl -X POST \"http://localhost:8000/articles\" \\\n-H \"Content-Type: application/vnd.api+json\" \\\n-d '{\n    \"data\": {\n        \"type\": \"articles\",\n        \"attributes\": {\n            \"title\": \"Sample Article\",\n            \"content\": \"This is a sample article.\"\n        }\n    }\n}'\n</code></pre> </li> <li> <p>Get an Article:</p> <pre><code>curl -X GET \"http://localhost:8000/articles/{article_id}\" \\\n-H \"Accept: application/vnd.api+json\"\n</code></pre> </li> <li> <p>List Articles:</p> <pre><code>curl -X GET \"http://localhost:8000/articles\" \\\n-H \"Accept: application/vnd.api+json\"\n</code></pre> </li> <li> <p>Update an Article:</p> <pre><code>curl -X PATCH \"http://localhost:8000/articles/{article_id}\" \\\n-H \"Content-Type: application/vnd.api+json\" \\\n-d '{\n    \"data\": {\n        \"type\": \"articles\",\n        \"id\": \"{article_id}\",\n        \"attributes\": {\n            \"title\": \"Updated Title\",\n            \"content\": \"Updated content.\"\n        }\n    }\n}'\n</code></pre> </li> <li> <p>Delete an Article:</p> <pre><code>curl -X DELETE \"http://localhost:8000/articles/{article_id}\" \\\n-H \"Accept: application/vnd.api+json\"\n</code></pre> </li> </ul>"},{"location":"examples/simple-usage/#conclusion","title":"Conclusion","text":"<p>This example demonstrates how to build a JSON:API-compliant FastAPI application using PyJAS and Supabase. By following the JSON:API standards, you ensure that your API is consistent, maintainable, and easily consumable by various clients.</p> <p>For more advanced usage and features, refer to the official documentation.</p>"},{"location":"getting-started/changelog/","title":"CHANGELOG","text":""},{"location":"getting-started/changelog/#v020-2024-09-25","title":"v0.2.0 (2024-09-25)","text":""},{"location":"getting-started/changelog/#feature","title":"Feature","text":"<ul> <li> <p>feat: first mvp with simple, Pydantic models (#2)</p> </li> <li> <p>feat: simpler version with Pydantic; tests not working</p> </li> <li>feat: add coverage</li> <li>feat: complete coverage and add test build steps</li> <li>docs: provide better documentation site and repo collab docs</li> <li>fix: fixing build issues (<code>3cebb77</code>)</li> </ul>"},{"location":"getting-started/changelog/#v010-2024-09-10","title":"v0.1.0 (2024-09-10)","text":""},{"location":"getting-started/changelog/#feature_1","title":"Feature","text":"<ul> <li> <p>feat: proof of concept (#1)</p> </li> <li> <p>feat: initial commit</p> </li> <li>chore: updates to repo and keywords</li> <li>feat: updates to core objects</li> <li>feat: add first parameters and responses</li> <li>feat: first draft of 1.1</li> <li>docs: update for go-live preview</li> <li>ci: update publish yml</li> <li>chore: mypy corrections</li> <li>ci: update for packaging</li> <li>ci: fix F401 and incorrect excludes (<code>55d2d6d</code>)</li> </ul>"},{"location":"getting-started/changelog/#unknown","title":"Unknown","text":"<ul> <li>Initial commit (<code>f4529f1</code>)</li> </ul> <p> ... and so on. For the full changelog, please see the releases page.</p>"},{"location":"getting-started/contributing/","title":"Contributing","text":"<p>We welcome contributions and volunteers for the project! Please read the following guidelines before contributing.</p>"},{"location":"getting-started/contributing/#issues","title":"Issues","text":"<p>Questions, bug reports, and feature requests are welcome as discussions or issues. Please search the existing issues before opening a new one. To report a security vulneratbility, please see the security policy.</p> <p>To help us resolve your issue, please provide the following information:</p> <ul> <li>Expected behavior: A clear and concise description of what you expected to happen.</li> <li>Actual behavior: A clear and concise description of what actually happened.</li> <li>Steps to reproduce: How can we reproduce the issue?</li> <li>Environment: Include relevant details like the operating system, Python version, and any other relevant information.</li> </ul>"},{"location":"getting-started/contributing/#pull-requests","title":"Pull Requests","text":"<p>We welcome pull requests for bug fixes, new features, and improvements. We aim to provide feedback regularly and will review your pull request as soon as possible. </p> <p>Unless your change is not trivial, please create an issue before submitting a pull request. This will allow us to discuss the change and ensure it aligns with the project goals.</p>"},{"location":"getting-started/contributing/#prerequisites","title":"Prerequisites","text":"<p>You will need the following to start developing:</p> <ul> <li>Python 3.10+</li> <li>virtualenv, poetry, or pipenv for the development environment.</li> <li>git for version control.</li> <li>make for running the Makefile commands.</li> </ul>"},{"location":"getting-started/contributing/#installation-setup","title":"Installation &amp; Setup","text":"<p>Fork the repository on GitHub and clone your fork locally. Then, install the dependencies:</p> <pre><code># Clone your fork and cd into the repo directory\ngit clone git@github.com:&lt;your username&gt;/PyJAS.git\ncd PyJAS\n\n# Install the dependencies\n# e.g., using poetry\npoetry install\n\n# Setup pre-commit\nmake pre-commit-setup\n</code></pre>"},{"location":"getting-started/contributing/#checkout-a-new-branch","title":"Checkout a New Branch","text":"<p>Create a new branch for your changes:</p> <pre><code># Create a new branch\ngit checkout -b my-new-feature\n</code></pre>"},{"location":"getting-started/contributing/#run-tests-linting-formatting-type-checking-pre-commit-hooks","title":"Run Tests, Linting, Formatting, Type checking, &amp; Pre-Commit Hooks","text":"<p>Before submitting a pull request, ensure that the tests pass, the code is formatted correctly, and the code passes the linting and type checking checks:</p> <pre><code># Run tests\nmake test\n\n# Run linting &amp; formatting\nmake lint\nmake format\nmake check-types\n\n# Run pre-commit hooks\nmake pre-commit\n</code></pre>"},{"location":"getting-started/contributing/#build-documentation","title":"Build Documentation","text":"<p>If you make changes to the documentation, you can build the documentation locally:</p> <pre><code># Build the documentation\nmake serve-docs\n</code></pre>"},{"location":"getting-started/contributing/#commit-and-push-your-changes","title":"Commit and Push your Changes","text":"<p>Commit your changes, push to your forked repository, and create a pull request:</p> <p>Please follow the pull request template and fill in as much information as possible. Link to any relevant issues and include a description of your changes.</p> <p>When your pull request is ready for review, add a comment with the message \"please review\" and we'll take a look as soon as we can.</p>"},{"location":"getting-started/contributing/#code-style-conventions","title":"Code Style &amp; Conventions","text":""},{"location":"getting-started/contributing/#documentation-style","title":"Documentation Style","text":"<p>Documentation is written in format and follows the Markdown Style Guide. Please ensure that the documentation is clear, concise, and easy to read. API documentation is generated using mkdocs &amp; mkdocstrings. We follow google-style docstrings.</p>"},{"location":"getting-started/contributing/#code-documentation","title":"Code Documentation","text":"<p>Please ensure that the code is well-documented and easy to understand when contributing. The following should be documented using proper docstrings:</p> <ul> <li>Modules</li> <li>Class Definitions</li> <li>Function Definitions</li> <li>Module-level Variables</li> </ul> <p><code>PyJAS</code> uses Google-style docstrings according to PEP 257. Please see the example for more information.</p> <p>Class attributes and function arguments should be documented in the style of \"name: description\" &amp; include an annotated type and return type when applicable. Feel free to include example code in docstrings. </p>"},{"location":"getting-started/help/","title":"Getting help with PyJAS","text":""},{"location":"getting-started/help/#have-an-issue","title":"Have an issue?","text":"<p>If you have any issues with PyJAS, feel free to open an issue. However, please understand that this is a growing project and I may not be able to address all issues immediately or monitor as actively as a full time maintainer or team.</p>"},{"location":"getting-started/help/#need-help","title":"Need help?","text":"<p>The API documents &amp; examples are the best source reference documentation for PyJAS.</p>"},{"location":"getting-started/help/#stack-overflow","title":"Stack Overflow","text":"<p>If you have a question about how to use PyJAS, please ask on Stack Overflow. Tag your question with <code>PyJAS</code> so that the community can see it.</p>"},{"location":"getting-started/installation/","title":"Installation","text":"<p>To install the package, you can use the following command:</p> <pre><code>pip install pyjas\n</code></pre> <p>There are a few evolving dependencies that will need to be installed as well &amp; to take note of:</p> <ul> <li>pydantic-v2: A data validation and settings management using Python type annotations. We may integrate for v1 in the future.</li> </ul> <p>If you have Python 3.10+ installed, you should be fine, but please report any issues you encounter.</p>"},{"location":"getting-started/installation/#install-from-source","title":"Install from source","text":"<p>To install the package from source, you can use the following command:</p> <pre><code>pip install git+https://github.com/kmbhm1/PyJAS.git@main\n</code></pre>"},{"location":"getting-started/security/","title":"Security Policy","text":"<p>If you discover a security issue, please bring it to our attention right away!</p>"},{"location":"getting-started/security/#supported-versions","title":"Supported Versions","text":"<p>Project versions that are currently being supported with security updates vary per project. Please see specific project repositories for details. If nothing is specified, only the latest major versions are supported.</p>"},{"location":"getting-started/security/#reporting-a-vulnerability","title":"Reporting a Vulnerability","text":"<p>Please DO NOT file a public issue to report a security vulberability, instead send your report privately to @kmbhm1. This will help ensure that any vulnerabilities that are found can be disclosed responsibly to any affected parties.</p>"},{"location":"getting-started/welcome/","title":"Welcome to the Python JSONAPI-Standard (PyJAS) Documentation!","text":"<p>Welcome to PyJAS, a robust Python library designed to seamlessly integrate the JSON:API specification with Python and Pydantic. Whether you're building a new API or enhancing an existing one, PyJAS provides the tools you need to ensure your API adheres to best practices and standards.</p>"},{"location":"getting-started/welcome/#why-pyjas","title":"Why PyJAS?","text":"<ul> <li>Standards-Compliant: Fully adheres to the JSON:API specification, ensuring interoperability and consistency. If you find this is not the case, please report an issue.</li> <li>Pydantic Powered: Leverages Pydantic's powerful data validation and parsing capabilities.</li> <li>FastAPI Integration: Easily integrates with FastAPI to build high-performance APIs.</li> <li>Extensible: Flexible architecture allows for customization and extension to fit your project's needs.</li> <li>Work in Progress: Continuously evolving with new features and improvements based on community feedback.</li> </ul>"},{"location":"getting-started/welcome/#getting-started","title":"Getting Started","text":"<p>This documentation site is a work in progress. Here, you'll find guides, examples, and API references to help you make the most of PyJAS. Stay tuned for more updates!</p>"},{"location":"getting-started/welcome/#join-the-community","title":"Join the Community","text":"<p>Contribute to the project, report issues, or suggest features on our GitHub repository. We welcome contributions from developers of all skill levels!</p> <p></p>"}]}